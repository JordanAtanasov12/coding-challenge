{"ast":null,"code":"const ERC20Abi = require('./ERC20Abi');\n/**\n * Class used to manipulate with ERC-20 token contracts\n */\n\n\nclass ERC20Contract {\n  /**\n   * Constructor\n   *\n   * @param {Web3} web3 Web3 instance\n   * @param {string} contractAddr Contract address\n   * @param {Array|null} [contractAbi=null] Contract ABI (optional)\n   */\n  constructor(web3, contractAddr) {\n    let contractAbi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (typeof web3 !== 'object' || typeof web3.eth !== 'object' || typeof web3.eth.Contract !== 'function') {\n      throw new Error('First parameter should be a Web3 instance');\n    }\n\n    if (!/^0x[0-9a-f]{40}$/i.test(contractAddr)) {\n      throw new Error('Second parameter should be a valid Ethereum address');\n    }\n\n    this._web3 = web3;\n    this._address = contractAddr;\n    const abi = contractAbi !== null ? contractAbi : ERC20Abi;\n    this._contractInst = new this._web3.eth.Contract(abi, this._address);\n  }\n  /**\n   * Get contract address\n   *\n   * @return {string}\n   */\n\n\n  getAddress() {\n    return this._address;\n  }\n  /**\n   * Get contract instance\n   *\n   * @return {Contract}\n   */\n\n\n  getInstance() {\n    return this._contractInst;\n  }\n  /**\n   * Get Web3 instance\n   *\n   * @return {Web3}\n   */\n\n\n  getWeb3() {\n    return this._web3;\n  }\n  /**\n   * Get total amount of tokens\n   *\n   * function totalSupply() public constant returns (uint)\n   *\n   * @return {TransactionObject} Total supply\n   */\n\n\n  totalSupply() {\n    return this._contractInst.methods['totalSupply']();\n  }\n  /**\n   * Get the token balance of account\n   *\n   * function balanceOf(address tokenOwner) public constant returns (uint balance)\n   *\n   * @param {string} walletAddr The address from which the balance will be retrieved\n   * @return {TransactionObject} The balance\n   */\n\n\n  balanceOf(walletAddr) {\n    return this._contractInst.methods['balanceOf'](walletAddr);\n  }\n  /**\n   * Get amount of remaining tokens allowed to spent\n   *\n   * function allowance(address tokenOwner, address spender) public constant returns (uint remaining)\n   *\n   * @param {string} walletAddr The address of the account owning tokens\n   * @param {string} spenderAddr The address of the account able to transfer the tokens\n   * @return {TransactionObject} Amount of remaining tokens allowed to spent\n   */\n\n\n  allowance(walletAddr, spenderAddr) {\n    return this._contractInst.methods['allowance'](walletAddr, spenderAddr);\n  }\n  /**\n   * Send \"value\" amount of tokens to address \"toAddr\"\n   *\n   * function transfer(address to, uint tokens) public returns (bool success)\n   *\n   * @param {string} toAddr The address of the recipient\n   * @param {string} value The amount of token to be transferred\n   * @return {TransactionObject} Whether the transfer was successful or not\n   */\n\n\n  transfer(toAddr, value) {\n    return this._contractInst.methods['transfer'](toAddr, value);\n  }\n  /**\n   * Send \"value\" amount of tokens from address \"fromAddr\" to address \"toAddr\"\n   *\n   * function transferFrom(address from, address to, uint tokens) public returns (bool success)\n   *\n   * @param {string} fromAddr The address of the sender\n   * @param {string} toAddr The address of the recipient\n   * @param {string} value The amount of token to be transferred\n   * @return {TransactionObject} Whether the transfer was successful or not\n   */\n\n\n  transferFrom(fromAddr, toAddr, value) {\n    return this._contractInst.methods['transferFrom'](fromAddr, toAddr, value);\n  }\n  /**\n   * Allow \"spenderAddr\" to withdraw from your account, multiple times, up to the \"value\" amount\n   *\n   * function approve(address spender, uint tokens) public returns (bool success)\n   *\n   * @param {string} spenderAddr The address of the account able to transfer the tokens\n   * @param {string} value The amount of wei to be approved for transfer\n   * @return {TransactionObject} Whether the approval was successful or not\n   */\n\n\n  approve(spenderAddr, value) {\n    return this._contractInst.methods['approve'](spenderAddr, value);\n  }\n  /**\n   * Triggered when tokens are transferred\n   *\n   * event Transfer(address indexed from, address indexed to, uint tokens)\n   *\n   * @param {Object} [options] The options used for deployment\n   * @return {EventEmitter}\n   */\n\n\n  onTransfer(options) {\n    return this._contractInst.events['Transfer'](options);\n  }\n  /**\n   * Triggered whenever approve is called\n   *\n   * event Approval(address indexed tokenOwner, address indexed spender, uint tokens)\n   *\n   * @param {Object} [options] The options used for deployment\n   * @return {EventEmitter}\n   */\n\n\n  onApproval(options) {\n    return this._contractInst.events['Approval'](options);\n  }\n  /**\n   * Get past transfer events\n   *\n   * @param {Object} [options] The options used for deployment\n   * @return {Promise<EventLog[]>}\n   */\n\n\n  peTransfer(options) {\n    return this._contractInst.getPastEvents('Transfer', options);\n  }\n  /**\n   * Get past approval events\n   *\n   * @param {Object} [options] The options used for deployment\n   * @return {Promise<EventLog[]>}\n   */\n\n\n  peApproval(options) {\n    return this._contractInst.getPastEvents('Approval', options);\n  }\n  /**\n   * Get token decimals\n   * Warning: This function is not part of ERC20 interface, so it may fail if contract does not has it\n   *\n   * uint8 public constant decimals\n   *\n   * @return {TransactionObject} Token decimals\n   */\n\n\n  decimals() {\n    return this._contractInst.methods['decimals']();\n  }\n  /**\n   * Get token symbol\n   * Warning: This function is not part of ERC20 interface, so it may fail if contract does not has it\n   *\n   * string public constant symbol\n   *\n   * @return {TransactionObject} Token symbol\n   */\n\n\n  symbol() {\n    return this._contractInst.methods['symbol']();\n  }\n  /**\n   * Get token name\n   * Warning: This function is not part of ERC20 interface, so it may fail if contract does not has it\n   *\n   * string public constant name\n   *\n   * @return {TransactionObject} Token name\n   */\n\n\n  name() {\n    return this._contractInst.methods['name']();\n  }\n\n}\n\nmodule.exports = ERC20Contract;","map":{"version":3,"names":["ERC20Abi","require","ERC20Contract","constructor","web3","contractAddr","contractAbi","eth","Contract","Error","test","_web3","_address","abi","_contractInst","getAddress","getInstance","getWeb3","totalSupply","methods","balanceOf","walletAddr","allowance","spenderAddr","transfer","toAddr","value","transferFrom","fromAddr","approve","onTransfer","options","events","onApproval","peTransfer","getPastEvents","peApproval","decimals","symbol","name","module","exports"],"sources":["/Users/jatanasov/Documents/Projects/Colony/coding-challenge-events-list-bootstrap/node_modules/erc20-contract-js/src/ERC20Contract.js"],"sourcesContent":["const ERC20Abi = require('./ERC20Abi');\n\n/**\n * Class used to manipulate with ERC-20 token contracts\n */\nclass ERC20Contract {\n\t/**\n\t * Constructor\n\t *\n\t * @param {Web3} web3 Web3 instance\n\t * @param {string} contractAddr Contract address\n\t * @param {Array|null} [contractAbi=null] Contract ABI (optional)\n\t */\n\tconstructor(web3, contractAddr, contractAbi = null) {\n\t\tif (typeof web3 !== 'object'\n\t\t\t|| typeof web3.eth !== 'object'\n\t\t\t|| typeof web3.eth.Contract !== 'function'\n\t\t) {\n\t\t\tthrow new Error('First parameter should be a Web3 instance');\n\t\t}\n\n\t\tif (!/^0x[0-9a-f]{40}$/i.test(contractAddr)) {\n\t\t\tthrow new Error('Second parameter should be a valid Ethereum address');\n\t\t}\n\n\t\tthis._web3 = web3;\n\t\tthis._address = contractAddr;\n\n\t\tconst abi = contractAbi !== null ? contractAbi : ERC20Abi;\n\n\t\tthis._contractInst = new this._web3.eth.Contract(abi, this._address);\n\t}\n\n\t/**\n\t * Get contract address\n\t *\n\t * @return {string}\n\t */\n\tgetAddress() {\n\t\treturn this._address;\n\t}\n\n\t/**\n\t * Get contract instance\n\t *\n\t * @return {Contract}\n\t */\n\tgetInstance() {\n\t\treturn this._contractInst;\n\t}\n\n\t/**\n\t * Get Web3 instance\n\t *\n\t * @return {Web3}\n\t */\n\tgetWeb3() {\n\t\treturn this._web3;\n\t}\n\n\t/**\n\t * Get total amount of tokens\n\t *\n\t * function totalSupply() public constant returns (uint)\n\t *\n\t * @return {TransactionObject} Total supply\n\t */\n\ttotalSupply() {\n\t\treturn this._contractInst.methods['totalSupply']();\n\t}\n\n\t/**\n\t * Get the token balance of account\n\t *\n\t * function balanceOf(address tokenOwner) public constant returns (uint balance)\n\t *\n\t * @param {string} walletAddr The address from which the balance will be retrieved\n\t * @return {TransactionObject} The balance\n\t */\n\tbalanceOf(walletAddr) {\n\t\treturn this._contractInst.methods['balanceOf'](walletAddr);\n\t}\n\n\t/**\n\t * Get amount of remaining tokens allowed to spent\n\t *\n\t * function allowance(address tokenOwner, address spender) public constant returns (uint remaining)\n\t *\n\t * @param {string} walletAddr The address of the account owning tokens\n\t * @param {string} spenderAddr The address of the account able to transfer the tokens\n\t * @return {TransactionObject} Amount of remaining tokens allowed to spent\n\t */\n\tallowance(walletAddr, spenderAddr) {\n\t\treturn this._contractInst.methods['allowance'](walletAddr, spenderAddr);\n\t}\n\n\t/**\n\t * Send \"value\" amount of tokens to address \"toAddr\"\n\t *\n\t * function transfer(address to, uint tokens) public returns (bool success)\n\t *\n\t * @param {string} toAddr The address of the recipient\n\t * @param {string} value The amount of token to be transferred\n\t * @return {TransactionObject} Whether the transfer was successful or not\n\t */\n\ttransfer(toAddr, value) {\n\t\treturn this._contractInst.methods['transfer'](toAddr, value);\n\t}\n\n\t/**\n\t * Send \"value\" amount of tokens from address \"fromAddr\" to address \"toAddr\"\n\t *\n\t * function transferFrom(address from, address to, uint tokens) public returns (bool success)\n\t *\n\t * @param {string} fromAddr The address of the sender\n\t * @param {string} toAddr The address of the recipient\n\t * @param {string} value The amount of token to be transferred\n\t * @return {TransactionObject} Whether the transfer was successful or not\n\t */\n\ttransferFrom(fromAddr, toAddr, value) {\n\t\treturn this._contractInst.methods['transferFrom'](fromAddr, toAddr, value);\n\t}\n\n\t/**\n\t * Allow \"spenderAddr\" to withdraw from your account, multiple times, up to the \"value\" amount\n\t *\n\t * function approve(address spender, uint tokens) public returns (bool success)\n\t *\n\t * @param {string} spenderAddr The address of the account able to transfer the tokens\n\t * @param {string} value The amount of wei to be approved for transfer\n\t * @return {TransactionObject} Whether the approval was successful or not\n\t */\n\tapprove(spenderAddr, value) {\n\t\treturn this._contractInst.methods['approve'](spenderAddr, value);\n\t}\n\n\t/**\n\t * Triggered when tokens are transferred\n\t *\n\t * event Transfer(address indexed from, address indexed to, uint tokens)\n\t *\n\t * @param {Object} [options] The options used for deployment\n\t * @return {EventEmitter}\n\t */\n\tonTransfer(options) {\n\t\treturn this._contractInst.events['Transfer'](options);\n\t}\n\n\t/**\n\t * Triggered whenever approve is called\n\t *\n\t * event Approval(address indexed tokenOwner, address indexed spender, uint tokens)\n\t *\n\t * @param {Object} [options] The options used for deployment\n\t * @return {EventEmitter}\n\t */\n\tonApproval(options) {\n\t\treturn this._contractInst.events['Approval'](options);\n\t}\n\n\t/**\n\t * Get past transfer events\n\t *\n\t * @param {Object} [options] The options used for deployment\n\t * @return {Promise<EventLog[]>}\n\t */\n\tpeTransfer(options) {\n\t\treturn this._contractInst.getPastEvents('Transfer', options);\n\t}\n\n\t/**\n\t * Get past approval events\n\t *\n\t * @param {Object} [options] The options used for deployment\n\t * @return {Promise<EventLog[]>}\n\t */\n\tpeApproval(options) {\n\t\treturn this._contractInst.getPastEvents('Approval', options);\n\t}\n\n\t/**\n\t * Get token decimals\n\t * Warning: This function is not part of ERC20 interface, so it may fail if contract does not has it\n\t *\n\t * uint8 public constant decimals\n\t *\n\t * @return {TransactionObject} Token decimals\n\t */\n\tdecimals() {\n\t\treturn this._contractInst.methods['decimals']();\n\t}\n\n\t/**\n\t * Get token symbol\n\t * Warning: This function is not part of ERC20 interface, so it may fail if contract does not has it\n\t *\n\t * string public constant symbol\n\t *\n\t * @return {TransactionObject} Token symbol\n\t */\n\tsymbol() {\n\t\treturn this._contractInst.methods['symbol']();\n\t}\n\n\t/**\n\t * Get token name\n\t * Warning: This function is not part of ERC20 interface, so it may fail if contract does not has it\n\t *\n\t * string public constant name\n\t *\n\t * @return {TransactionObject} Token name\n\t */\n\tname() {\n\t\treturn this._contractInst.methods['name']();\n\t}\n}\n\nmodule.exports = ERC20Contract;"],"mappings":"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"},"metadata":{},"sourceType":"script"}