{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"ethers/utils\");\n\nconst constants_1 = require(\"../constants\");\n\nconst TokenFactory_1 = require(\"../contracts/4/TokenFactory\");\n\nconst TokenErc20Factory_1 = require(\"../contracts/4/TokenErc20Factory\");\n\nconst TokenSaiFactory_1 = require(\"../contracts/4/TokenSaiFactory\");\n\nconst isSai = address => utils_1.getAddress(address) === constants_1.tokenAddresses.SAI;\n\nconst getTokenClient = (address, signerOrProvider) => __awaiter(void 0, void 0, void 0, function* () {\n  let tokenClient;\n  let isColonyToken = false;\n  tokenClient = TokenFactory_1.TokenFactory.connect(address, signerOrProvider); // Colony tokens have the `locked()` method. We assume that when it exists on\n  // the contract we have a ColonyToken ðŸ¦†. This might not be true though, so can't rely\n  // on this 100% when trying to call contract methods\n\n  try {\n    yield tokenClient.locked();\n    isColonyToken = true;\n  } catch (_a) {\n    isColonyToken = false;\n  }\n\n  if (isColonyToken) {\n    tokenClient.tokenClientType = constants_1.TokenClientType.Colony;\n  } else if (isSai(address)) {\n    tokenClient = TokenSaiFactory_1.TokenSaiFactory.connect(address, signerOrProvider);\n    tokenClient.tokenClientType = constants_1.TokenClientType.Dai;\n  } else {\n    tokenClient = TokenErc20Factory_1.TokenErc20Factory.connect(address, signerOrProvider);\n    tokenClient.tokenClientType = constants_1.TokenClientType.Erc20;\n  } // Before we go, let's check if this resembles a valid ERC20 token, for good measure\n\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore https://github.com/ethereum-ts/TypeChain/pull/255\n    yield tokenClient.estimate.transfer(address, 0, {\n      from: address\n    });\n  } catch (err) {\n    throw new Error(`Token is probably not a valid ERC20 token, got ${err}`);\n  }\n\n  tokenClient.clientType = constants_1.ClientType.TokenClient;\n\n  tokenClient.getTokenInfo = () => __awaiter(void 0, void 0, void 0, function* () {\n    let name = yield tokenClient.name(); // Special case for contracts with bytes32 strings (I'm looking at you, DAI)\n\n    if (utils_1.isHexString(name)) {\n      name = utils_1.parseBytes32String(name);\n    }\n\n    let symbol = yield tokenClient.symbol();\n\n    if (utils_1.isHexString(symbol)) {\n      symbol = utils_1.parseBytes32String(symbol);\n    }\n\n    const decimals = yield tokenClient.decimals();\n    return {\n      name,\n      symbol,\n      decimals\n    };\n  });\n\n  return tokenClient;\n});\n\nexports.default = getTokenClient;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","utils_1","require","constants_1","TokenFactory_1","TokenErc20Factory_1","TokenSaiFactory_1","isSai","address","getAddress","tokenAddresses","SAI","getTokenClient","signerOrProvider","tokenClient","isColonyToken","TokenFactory","connect","locked","_a","tokenClientType","TokenClientType","Colony","TokenSaiFactory","Dai","TokenErc20Factory","Erc20","estimate","transfer","from","err","Error","clientType","ClientType","TokenClient","getTokenInfo","name","isHexString","parseBytes32String","symbol","decimals","default"],"sources":["/Users/jatanasov/Documents/Projects/Colony_BACKUP/coding-challenge-events-list-bootstrap/node_modules/@colony/colony-js/lib/clients/TokenClient.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"ethers/utils\");\nconst constants_1 = require(\"../constants\");\nconst TokenFactory_1 = require(\"../contracts/4/TokenFactory\");\nconst TokenErc20Factory_1 = require(\"../contracts/4/TokenErc20Factory\");\nconst TokenSaiFactory_1 = require(\"../contracts/4/TokenSaiFactory\");\nconst isSai = (address) => utils_1.getAddress(address) === constants_1.tokenAddresses.SAI;\nconst getTokenClient = (address, signerOrProvider) => __awaiter(void 0, void 0, void 0, function* () {\n    let tokenClient;\n    let isColonyToken = false;\n    tokenClient = TokenFactory_1.TokenFactory.connect(address, signerOrProvider);\n    // Colony tokens have the `locked()` method. We assume that when it exists on\n    // the contract we have a ColonyToken ðŸ¦†. This might not be true though, so can't rely\n    // on this 100% when trying to call contract methods\n    try {\n        yield tokenClient.locked();\n        isColonyToken = true;\n    }\n    catch (_a) {\n        isColonyToken = false;\n    }\n    if (isColonyToken) {\n        tokenClient.tokenClientType = constants_1.TokenClientType.Colony;\n    }\n    else if (isSai(address)) {\n        tokenClient = TokenSaiFactory_1.TokenSaiFactory.connect(address, signerOrProvider);\n        tokenClient.tokenClientType = constants_1.TokenClientType.Dai;\n    }\n    else {\n        tokenClient = TokenErc20Factory_1.TokenErc20Factory.connect(address, signerOrProvider);\n        tokenClient.tokenClientType = constants_1.TokenClientType.Erc20;\n    }\n    // Before we go, let's check if this resembles a valid ERC20 token, for good measure\n    try {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore https://github.com/ethereum-ts/TypeChain/pull/255\n        yield tokenClient.estimate.transfer(address, 0, {\n            from: address,\n        });\n    }\n    catch (err) {\n        throw new Error(`Token is probably not a valid ERC20 token, got ${err}`);\n    }\n    tokenClient.clientType = constants_1.ClientType.TokenClient;\n    tokenClient.getTokenInfo = () => __awaiter(void 0, void 0, void 0, function* () {\n        let name = yield tokenClient.name();\n        // Special case for contracts with bytes32 strings (I'm looking at you, DAI)\n        if (utils_1.isHexString(name)) {\n            name = utils_1.parseBytes32String(name);\n        }\n        let symbol = yield tokenClient.symbol();\n        if (utils_1.isHexString(symbol)) {\n            symbol = utils_1.parseBytes32String(symbol);\n        }\n        const decimals = yield tokenClient.decimals();\n        return {\n            name,\n            symbol,\n            decimals,\n        };\n    });\n    return tokenClient;\n});\nexports.default = getTokenClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}