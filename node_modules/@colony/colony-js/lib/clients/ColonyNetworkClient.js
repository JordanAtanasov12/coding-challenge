"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const constants_2 = require("../constants");
// @TODO this _HAS_ to be the newest version _ALWAYS_. Let's try to figure out a way to make sure of this
const IColonyNetworkFactory_1 = require("../contracts/4/IColonyNetworkFactory");
const Token_json_1 = require("../contracts/deploy/Token.json");
const ColonyVersionClient_1 = require("./Colony/ColonyVersionClient");
const ColonyClientV1_1 = require("./Colony/ColonyClientV1");
const ColonyClientV2_1 = require("./Colony/ColonyClientV2");
const ColonyClientV3_1 = require("./Colony/ColonyClientV3");
const ColonyClientV4_1 = require("./Colony/ColonyClientV4");
const TokenClient_1 = require("./TokenClient");
const TokenLockingClient_1 = require("./TokenLockingClient");
const OneTxPaymentDeployerClient_1 = require("./OneTxPaymentDeployerClient");
const OneTxPaymentClient_1 = require("./OneTxPaymentClient");
const getColonyNetworkClient = (network = constants_2.Network.Mainnet, signerOrProvider, options) => {
    const networkAddress = options && options.networkAddress
        ? options.networkAddress
        : constants_2.colonyNetworkAddresses[network];
    if (!networkAddress) {
        throw new Error(`Could not get ColonyNetwork address for ${network}. Please specify`);
    }
    const networkClient = IColonyNetworkFactory_1.IColonyNetworkFactory.connect(networkAddress, signerOrProvider);
    networkClient.clientType = constants_2.ClientType.NetworkClient;
    networkClient.network = network;
    networkClient.reputationOracleEndpoint =
        (options && options.reputationOracleEndpoint) || constants_2.REPUTATION_ORACLE_ENDPOINT;
    // @TODO move to getter function `getOneTxPaymentFactorylient` as we do with all the others
    networkClient.oneTxPaymentFactoryClient = OneTxPaymentDeployerClient_1.default(network, signerOrProvider, options && options.oneTxPaymentFactoryAddress);
    networkClient.getTokenLockingClient = () => __awaiter(void 0, void 0, void 0, function* () {
        const tokenLockingAddress = yield networkClient.getTokenLocking();
        return TokenLockingClient_1.default(tokenLockingAddress, signerOrProvider);
    });
    networkClient.getColonyClient = (addressOrId) => __awaiter(void 0, void 0, void 0, function* () {
        let colonyAddress;
        if (typeof addressOrId == 'number') {
            colonyAddress = yield networkClient.getColony(addressOrId);
        }
        else {
            colonyAddress = addressOrId;
        }
        const colonyVersionClient = ColonyVersionClient_1.default(colonyAddress, signerOrProvider);
        // This is *kinda* hacky, but I have no better idea ¯\_(ツ)_/¯
        // We have to get the version somehow before instantiating the right contract version
        const versionBN = yield colonyVersionClient.version();
        const version = versionBN.toNumber();
        let colonyClient;
        switch (version) {
            case constants_2.ColonyVersion.GoerliGlider: {
                colonyClient = ColonyClientV1_1.default.call(networkClient, colonyAddress, signerOrProvider);
                break;
            }
            case constants_2.ColonyVersion.Glider: {
                colonyClient = ColonyClientV2_1.default.call(networkClient, colonyAddress, signerOrProvider);
                break;
            }
            case constants_2.ColonyVersion.AuburnGlider: {
                colonyClient = ColonyClientV3_1.default.call(networkClient, colonyAddress, signerOrProvider);
                break;
            }
            case constants_2.ColonyVersion.BurgundyGlider: {
                colonyClient = ColonyClientV4_1.default.call(networkClient, colonyAddress, signerOrProvider);
                break;
            }
            default: {
                throw new Error('Colony version not supported');
            }
        }
        const tokenAddress = yield colonyClient.getToken();
        colonyClient.tokenClient = yield TokenClient_1.default(tokenAddress, signerOrProvider);
        // eslint-disable-next-line max-len
        const oneTxPaymentAddress = yield networkClient.oneTxPaymentFactoryClient.deployedExtensions(colonyClient.address);
        if (oneTxPaymentAddress !== constants_1.AddressZero) {
            colonyClient.oneTxPaymentClient = OneTxPaymentClient_1.default(oneTxPaymentAddress, colonyClient);
        }
        return colonyClient;
    });
    networkClient.getMetaColonyClient = () => __awaiter(void 0, void 0, void 0, function* () {
        const metaColonyAddress = yield networkClient.getMetaColony();
        return networkClient.getColonyClient(metaColonyAddress);
    });
    networkClient.lookupRegisteredENSDomainWithGoerliPatch = (addr) => __awaiter(void 0, void 0, void 0, function* () {
        const domain = yield networkClient.lookupRegisteredENSDomain(addr);
        if (domain && networkClient.network === constants_2.Network.Goerli) {
            const [name, scope] = domain.split('.');
            return `${name}.${scope}.joincolony.test`;
        }
        return domain;
    });
    networkClient.deployToken = (name, symbol, decimals = 18) => __awaiter(void 0, void 0, void 0, function* () {
        const tokenFactory = new ethers_1.ContractFactory(Token_json_1.abi, Token_json_1.bytecode, networkClient.signer);
        const tokenContract = yield tokenFactory.deploy(name, symbol, decimals);
        yield tokenContract.deployed();
        return tokenContract.deployTransaction;
    });
    networkClient.estimate.deployToken = (name, symbol, decimals = 18) => __awaiter(void 0, void 0, void 0, function* () {
        const tokenFactory = new ethers_1.ContractFactory(Token_json_1.abi, Token_json_1.bytecode);
        const deployTx = tokenFactory.getDeployTransaction(name, symbol, decimals);
        return networkClient.provider.estimateGas(deployTx);
    });
    return networkClient;
};
exports.default = getColonyNetworkClient;
